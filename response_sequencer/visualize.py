# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/library/07_Sequence_Visualization.ipynb.

# %% auto 0
__all__ = ['index_to_hex_color', 'flatten_matches', 'render_matched_response_spans']

# %% ../src/library/07_Sequence_Visualization.ipynb 3
#| code-summary: specify functions for HTML rendering of sequencing outputs as spans in a response.
import spacy
import numpy as np
from spacy import displacy
from typing import List, Dict
import matplotlib.pyplot as plt
import gradio as gr


def index_to_hex_color(idx: int, total: int, cmap: str ="viridis"):
    """
    Get RGB values from the colormap based on normalized index

    Parameters:
        idx (int): Index of the color
        total (int): Total number of colors
        cmap (str): Colormap name

    Returns:
        hex_color (str): Hex color code

    """
    normalized_idx = idx / float(total - 1)
    r, g, b, _ = plt.get_cmap(cmap)(normalized_idx)
    hex_color = "#{:02x}{:02x}{:02x}".format(int(255 * r), int(255 * g), int(255 * b))

    return hex_color

def flatten_matches(target_items, response_units, match_matrix):

    matched_target_items = []
    matched_response_units = []
    for idx, row in enumerate(match_matrix):
        if np.any(row):
            matched_target_items.append(target_items[idx])
            matched_response_units.append(response_units[np.argmax(row)])

    return matched_target_items, matched_response_units

def render_matched_response_spans(
        response: str, target_items, response_units, match_matrix, title):
    """
    Renders matched response units as spans in a response.

    Returns:
        html (str): HTML code for rendering the response with matched response units as spans.
    """

    matched_target_items, matched_response_units = flatten_matches(target_items, response_units, match_matrix)

    # create spacy span objects for each matched response unit
    nlp = spacy.load("en_core_web_sm")
    doc = nlp(response)

    if len(matched_response_units) == 0:
        return displacy.render(doc, style="ent")
    
    spans = []
    for idx, unit in enumerate(matched_response_units):
        if type(matched_target_items[idx]) is dict:
            span_label = matched_target_items[idx]["text"]
        else:
            span_label = matched_target_items[idx]

        spans.append(doc.char_span(
            start_idx=unit["spans"][0][0], end_idx=unit["spans"][0][1], 
            label=span_label))
        if spans[-1] is None:
            raise ValueError(f"Could not create span for {unit['spans'][0]}")

    # Generate colors based on the colormap
    colors = {span.label_: index_to_hex_color(idx, len(spans)) for idx, span in enumerate(spans)}
    doc.spans["sc"] = spans
    doc.user_data["title"] = title

    return displacy.render(doc, style="span", page=True, options={"colors": colors})
