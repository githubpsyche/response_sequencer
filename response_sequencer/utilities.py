# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/library/08_Utilities.ipynb.

# %% auto 0
__all__ = ['find_first_sublist_index', 'find_sublist_indices', 'generate_markdown_table', 'invert_match_mapping',
           'items_by_ordering', 'extract_recalled']

# %% ../src/library/08_Utilities.ipynb 1
def find_first_sublist_index(lst, sublist):
    """
    Find the first occurrence of a sublist within a larger list and return its starting index.
    
    Args:
        lst (list): The larger list to search within.
        sublist (list): The sublist to search for.
    
    Returns:
        index (int): The starting index of the first occurrence of the sublist, or -1 if not found.
    """
    sublist_len = len(sublist)
    if sublist_len == 0 or sublist_len > len(lst):
        return -1
    
    for i in range(len(lst) - sublist_len + 1):
        if lst[i:i + sublist_len] == sublist:
            return i
    
    return -1

def find_sublist_indices(lst, sublist):
    """
    Find all occurrences of a sublist within a larger list and return their starting indices.
    
    Args:
        lst (list): The larger list to search within.
        sublist (list): The sublist to search for.
    
    Returns:
        indices (list): A list of starting indices where the sublist occurs in the larger list.
    """
    indices = []
    sublist_len = len(sublist)
    if sublist_len == 0 or sublist_len > len(lst):
        return indices
    
    for i in range(len(lst) - sublist_len + 1):
        if lst[i:i + sublist_len] == sublist:
            indices.append(i)
    
    return indices

# %% ../src/library/08_Utilities.ipynb 2
from IPython.display import display, Markdown

def generate_markdown_table(data, column_names, skip_empty_rows=False):
    # Determine the number of columns based on the length of column_names
    num_columns = len(column_names)

    # Generate the header row for the markdown table
    header_row = "|"
    for name in column_names:
        header_row += f" {name} |"
    markdown = f"{header_row}\n"

    # Add a separator row for the markdown table
    separator_row = "|"
    for i in range(num_columns):
        separator_row += " --- |"
    markdown += f"{separator_row}\n"

    # Add the rows of data to the markdown table
    num_rows = max(len(lst) for lst in data)
    for i in range(num_rows):
        row = "|"
        empty_entries = 0
        for j in range(num_columns):
            if i < len(data[j]):
                row += f" {data[j][i]} |"
                if data[j][i] == "":
                    empty_entries += 1
            else:
                row += "   |"
                empty_entries += 1

        # Only add the row if it doesn't have any empty entries, or if skip_empty_rows is False
        if not (skip_empty_rows and empty_entries > 0):
            markdown += f"{row}\n"

    # Return the markdown string
    return Markdown(markdown)

# %% ../src/library/08_Utilities.ipynb 4
def invert_match_mapping(original_keys, target_keys, matching):
    """
    Inverts the match mapping between original_keys and target_keys.

    Given a matching represented as a list of target keys corresponding to each original key,
    this function inverts the mapping and creates a list of original keys corresponding to each target key.
    Unmatched target keys are represented by empty strings.

    Args:
        original_keys (List[str]): A list of original keys (e.g., response_units).
        target_keys (List[str]): A list of target keys (e.g., target_items).
        matching (List[str]): A list of matched target keys, one for each original key. Use empty strings for unmatched original keys.

    Returns:
        List[str]: A new list with the same length as target_keys, where each position contains the original key matched to the target key.
                   Unmatched target keys are represented by empty strings.
    """


    inverted_mapping = {target_key: "" for target_key in target_keys}
    for original_key, matched_target_key in zip(original_keys, matching):
        if matched_target_key:
            inverted_mapping[matched_target_key] = original_key
    return [inverted_mapping[key] for key in inverted_mapping]

# %% ../src/library/08_Utilities.ipynb 5
import numpy as np
from typing import List

def items_by_ordering(items: List[str], ordering: np.ndarray) -> List[str]:
    """
    Reorders a list of items based on the provided ordering.

    Args:
        items (List[str]): A list of items to be reordered.
        ordering (np.ndarray): A numpy array with the same length as items, where the value at each position
                               represents the index of the response unit the target item is matched to. Use
                               np.nan for items to be excluded..

    Returns:
        List[str]: items reordered according to the provided ordering.
    """
    
    ordered_items = [""] * int((np.nanmax(ordering) + 1))
    for target_index, response_index in enumerate(ordering):
        if not np.isnan(response_index):
            ordered_items[int(response_index)] = items[target_index]

    return [each for each in ordered_items if each]

# %% ../src/library/08_Utilities.ipynb 7
def extract_recalled(origText_recalled_posRec_recText):

    data = [r.strip().split('\t') for r in origText_recalled_posRec_recText.split('\n')]

    # Extract the origText and posRec columns from the data
    origText = [row[0] for row in data]
    posRec = [row[2] for row in data]

    # Create a list of tuples containing origText and posRec values
    origText_posRec = list(zip(origText, posRec))

    # Remove any NaN values from the posRec column
    origText_posRec = [(text, int(pos)) for text, pos in origText_posRec if pos != 'NaN']

    # Sort the list of tuples by the posRec value
    origText_posRec_sorted = sorted(origText_posRec, key=lambda x: x[1])

    # Extract just the sorted origText values from the list of tuples
    sorted_origText = [text for text, pos in origText_posRec_sorted]

    return sorted_origText
