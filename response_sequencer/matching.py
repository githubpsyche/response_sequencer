# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/library/04_Matching.ipynb.

# %% auto 0
__all__ = ['Matcher', 'MaximumScoreMatcher', 'OptimalSingleAssignmentMatcher', 'MutualEntailmentMatcher']

# %% ../src/library/04_Matching.ipynb 2
#| code-summary: specify an abstract base class for implementing response unit matching strategies
from abc import ABC, abstractmethod
from typing import List, Union, Dict

class Matcher(ABC):
    
    """
    Abstract base class for implementing response unit matching 
    strategies. To create a custom matcher, inherit from this 
    class and override the match method.
    """ 

    @abstractmethod
    def __call__(self, 
               response_units: Union[List[str], List[Dict[str, object]]], 
               target_items: Union[List[str], List[Dict[str, object]]],
               response_context: str, target_context: str) -> List[List[bool]]:
        """
        Matches the response_units to target_items based on a specific strategy.

        Args:
            response_units (Union[List[str], List[Dict[str, object]]]): List of response units. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            target_items (Union[List[str], List[Dict[str, object]]]): List of target items. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            response_context (str): The context of the response units.
            target_context (str): The context of the target items.

        Returns:
            List[List[bool]]: A list of lists representing a boolean matrix 
                of shape (len(target_items), len(response_units)). 
                Each element in the matrix indicates whether the corresponding
                response unit matches the corresponding target item.
        """

        pass

# %% ../src/library/04_Matching.ipynb 4
#| code-summary: implement a maximum score matcher
import numpy as np
from .scoring import Scorer
from typing import Optional
from .filtering import MatchFilter

class MaximumScoreMatcher(Matcher):
    """
    Concrete Matcher class that implements a maximum score approach
    for matching response units with target items. Utilizes a provided Scorer
    to compute scores and a Thresholder for filtering out low-quality matches.
    """

    def __init__(self, scorer: Scorer, match_filter: Optional[MatchFilter] = None):
        """
        Initializes the MaximumScoreMatcher with a specified scorer and thresholder.

        Args:
            scorer (Scorer): An initialized Scorer object.
            match_filter Optional[MatchFilter]: Optional initialized MatchFilter object.
        """
        self.scorer = scorer
        self.match_filter = match_filter

    def __call__(self, 
               response_units: Union[List[str], List[Dict[str, object]]], 
               target_items: Union[List[str], List[Dict[str, object]]],
               response_context: str = '', target_context: str = '') -> List[List[bool]]:
        """
        Matches the response_units to target_items based on a specific strategy.

        Args:
            response_units (Union[List[str], List[Dict[str, object]]]): List of response units. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            target_items (Union[List[str], List[Dict[str, object]]]): List of target items. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            response_context (str): The context of the response units.
            target_context (str): The context of the target items.

        Returns:
            np.ndarray: A boolean matrix of shape (len(target_items), len(response_units)). 
                Each element in the matrix indicates whether the corresponding
                response unit matches the corresponding target item.
        """

        scores_matrix = self.scorer(response_units, target_items, response_context, target_context)
        if self.match_filter is not None:
            scores_matrix = self.match_filter(response_units, target_items, scores_matrix)

        max_indices = np.argmax(scores_matrix, axis=1)
        max_values = scores_matrix[np.arange(len(target_items)), max_indices]

        match_matrix = np.zeros((len(target_items), len(response_units)), dtype=bool)
        match_matrix[np.arange(len(target_items)), max_indices] = (max_values != -np.inf)
        return match_matrix.tolist()


# %% ../src/library/04_Matching.ipynb 6
#| code-summary: implement an optimal assignment matcher using the Hungarian algorithm
import numpy as np
from scipy.optimize import linear_sum_assignment
from .scoring import Scorer
from .filtering import MatchFilter

class OptimalSingleAssignmentMatcher(Matcher):
    """
    Concrete Matcher class that implements an optimal assignment approach
    for matching response units with target items. Utilizes a provided Scorer
    to compute similarity scores and a Thresholder for filtering out low-quality matches.
    """

    def __init__(self, scorer: Scorer, match_filter: Optional[MatchFilter] = None):
        """
        Initializes the MaximumScoreMatcher with a specified scorer and thresholder.

        Args:
            scorer (Scorer): An initialized Scorer object.
            match_filter Optional[MatchFilter]: Optional initialized MatchFilter object.
        """
        self.scorer = scorer
        self.match_filter = match_filter

    def __call__(self, 
               response_units: Union[List[str], List[Dict[str, object]]], 
               target_items: Union[List[str], List[Dict[str, object]]],
               response_context: str = '', target_context: str = '') -> List[List[bool]]:
        """
        Matches the response_units to target_items based on a specific strategy.

        Args:
            response_units (Union[List[str], List[Dict[str, object]]]): List of response units. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            target_items (Union[List[str], List[Dict[str, object]]]): List of target items. 
                Each response unit can be a string or a dictionary (when both text and spans are available).

            response_context (str): The context of the response units.
            target_context (str): The context of the target items.

        Returns:
            np.ndarray: A boolean matrix of shape (len(target_items), len(response_units)). 
                Each element in the matrix indicates whether the corresponding
                response unit matches the corresponding target item.
        """

        scores_matrix = self.scorer(response_units, target_items, response_context, target_context)
        if self.match_filter is not None:
            scores_matrix = self.match_filter(response_units, target_items, scores_matrix)

        target_indices, response_indices = linear_sum_assignment(-scores_matrix)

        match_matrix = np.zeros((len(target_items), len(response_units)), dtype=bool)
        valid_indices = scores_matrix[target_indices, response_indices] != -np.inf
        match_matrix[target_indices[valid_indices], response_indices[valid_indices]] = True

        return match_matrix.tolist()

# %% ../src/library/04_Matching.ipynb 10
#| code-summary: implement a mutual entailment matcher using a CrossEncoder model
class MutualEntailmentMatcher(Matcher):
    def __init__(self, model_name: str):
        """
        Initialize the MutualEntailmentMatcher with a specified model.

        :param model_name: The name of the CrossEncoder model to use.
        """
        self.model = CrossEncoder(model_name)

    def match(self, response_units: list, target_items: list) -> list:
        """
        Match response units with target items using the CrossEncoder model
        based on mutual entailment.

        Args:
            response_units (List[str]): List of response items.
            target_items (List[str]): List of target items.

        Returns:
            List[str]: For each response unit, a string containing the matched target item. Empty strings are used for unmatched responses
        """
        forward_pair_scores = self.model.predict(list(product(response_units, target_items)))
        backward_pair_scores = self.model.predict(list(product(target_items, response_units)))

        forward_entailment_scores = []
        for pair_score in forward_pair_scores:
            if np.argmax(pair_score) == 1:
                forward_entailment_scores.append(pair_score[1])
            else:
                forward_entailment_scores.append(0.0)
        
        backward_entailment_scores = []
        for pair_score in backward_pair_scores:
            if np.argmax(pair_score) == 1:
                backward_entailment_scores.append(pair_score[1])
            else:
                backward_entailment_scores.append(0.0)

        minimum_entailment_scores = [min(forward_entailment_scores[i], backward_entailment_scores[i])
                                        for i in range(len(forward_entailment_scores))]

        forward_scores_matrix = [forward_entailment_scores[i:i + len(target_items)] for i in range(0, len(forward_entailment_scores), len(target_items))]
        minimum_scores_matrix = [minimum_entailment_scores[i:i + len(target_items)] for i in range(0, len(minimum_entailment_scores), len(target_items))]

        matched_items = ["" for _ in range(len(response_units))]
        for row_index, row in enumerate(forward_scores_matrix):
            max_score_index = row.index(max(row))
            if minimum_scores_matrix[row_index][max_score_index] > 0:
                matched_items[row_index] = target_items[max_score_index]

        return matched_items
